function O(e){return Array.isArray(e)?e:[e]}const G={STOP:"STOP"};function _(e,n){const t=n(e);e.children!==void 0&&t!==G.STOP&&e.children.forEach(r=>_(r,n))}function D(e,n={}){const{preserveGroup:t=!1}=n,r=[],s=t?i=>{i.isLeaf||(r.push(i.key),o(i.children))}:i=>{i.isLeaf||(i.isGroup||r.push(i.key),o(i.children))};function o(i){i.forEach(s)}return o(e),r}function F(e,n){const{isLeaf:t}=e;return t!==void 0?t:!n(e)}function R(e){return e.children}function j(e){return e.key}function U(){return!1}function q(e,n){const{isLeaf:t}=e;return!(t===!1&&!Array.isArray(n(e)))}function V(e){return e.disabled===!0}function W(e,n){return e.isLeaf===!1&&!Array.isArray(n(e))}function P(e){var n;return e==null?[]:Array.isArray(e)?e:(n=e.checkedKeys)!==null&&n!==void 0?n:[]}function x(e){var n;return e==null||Array.isArray(e)?[]:(n=e.indeterminateKeys)!==null&&n!==void 0?n:[]}function Z(e,n){const t=new Set(e);return n.forEach(r=>{t.has(r)||t.add(r)}),Array.from(t)}function z(e,n){const t=new Set(e);return n.forEach(r=>{t.has(r)&&t.delete(r)}),Array.from(t)}function B(e){return(e==null?void 0:e.type)==="group"}function ue(e){const n=new Map;return e.forEach((t,r)=>{n.set(t.key,r)}),t=>{var r;return(r=n.get(t))!==null&&r!==void 0?r:null}}class H extends Error{constructor(){super();this.message="SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded."}}function J(e,n,t){return A(n.concat(e),t)}function Q(e,n){const t=new Set;return e.forEach(r=>{const s=n.treeNodeMap.get(r);if(s!==void 0){let o=s.parent;for(;o!==null&&!(o.disabled||t.has(o.key));)t.add(o.key),o=o.parent}}),t}function X(e,n,t){const r=A(n,t),s=A(e,t,!0),o=Q(e,t),i=[];return r.forEach(c=>{(s.has(c)||o.has(c))&&i.push(c)}),i.forEach(c=>r.delete(c)),r}function E(e,n){const{checkedKeys:t,keysToCheck:r,keysToUncheck:s,indeterminateKeys:o,cascade:i,leafOnly:c,checkStrategy:h}=e;if(!i)return r!==void 0?{checkedKeys:Z(t,r),indeterminateKeys:Array.from(o)}:s!==void 0?{checkedKeys:z(t,s),indeterminateKeys:Array.from(o)}:{checkedKeys:Array.from(t),indeterminateKeys:Array.from(o)};const{levelTreeNodeMap:l}=n;let d;s!==void 0?d=X(s,t,n):r!==void 0?d=J(r,t,n):d=A(t,n);const f=h==="parent",v=h==="child"||c,k=d,S=new Set,C=Math.max.apply(null,Array.from(l.keys()));for(let b=C;b>=0;b-=1){const N=b===0,w=l.get(b);for(const p of w){if(p.isLeaf)continue;const{key:u,shallowLoaded:a}=p;if(v&&a&&p.children.forEach(y=>{!y.disabled&&!y.isLeaf&&y.shallowLoaded&&k.has(y.key)&&k.delete(y.key)}),p.disabled||!a)continue;let g=!0,m=!1,K=!0;for(const y of p.children){const T=y.key;if(!y.disabled){if(K&&(K=!1),k.has(T))m=!0;else if(S.has(T)){m=!0,g=!1;break}else if(g=!1,m)break}}g&&!K?(f&&p.children.forEach(y=>{!y.disabled&&k.has(y.key)&&k.delete(y.key)}),k.add(u)):m&&S.add(u),N&&v&&k.has(u)&&k.delete(u)}}return{checkedKeys:Array.from(k),indeterminateKeys:Array.from(S)}}function A(e,n,t=!1){const{treeNodeMap:r,getChildren:s}=n,o=new Set,i=new Set(e);return e.forEach(c=>{const h=r.get(c);h!==void 0&&_(h,l=>{if(l.disabled)return G.STOP;const{key:d}=l;if(!o.has(d)&&(o.add(d),i.add(d),W(l.rawNode,s))){if(t)return G.STOP;throw new H}})}),i}function Y(e,{includeGroup:n=!1,includeSelf:t=!0},r){var s;const o=r.treeNodeMap;let i=e==null?null:(s=o.get(e))!==null&&s!==void 0?s:null;const c={keyPath:[],treeNodePath:[],treeNode:i};if(i==null?void 0:i.ignored)return c.treeNode=null,c;for(;i;)!i.ignored&&(n||!i.isGroup)&&c.treeNodePath.push(i),i=i.parent;return c.treeNodePath.reverse(),t||c.treeNodePath.pop(),c.keyPath=c.treeNodePath.map(h=>h.key),c}function $(e){if(e.length===0)return null;const n=e[0];return n.isGroup||n.ignored||n.disabled?n.getNext():n}function ee(e,n){const t=e.siblings,r=t.length,{index:s}=e;return n?t[(s+1)%r]:s===t.length-1?null:t[s+1]}function I(e,n,{loop:t=!1,includeDisabled:r=!1}={}){const s=n==="prev"?te:ee,o={reverse:n==="prev"};let i=!1,c=null;function h(l){if(l!==null){if(l===e){if(!i)i=!0;else if(!e.disabled&&!e.isGroup){c=e;return}}else if((!l.disabled||r)&&!l.ignored&&!l.isGroup){c=l;return}if(l.isGroup){const d=L(l,o);d!==null?c=d:h(s(l,t))}else{const d=s(l,!1);if(d!==null)h(d);else{const f=ne(l);(f==null?void 0:f.isGroup)?h(s(f,t)):t&&h(s(l,!0))}}}}return h(e),c}function te(e,n){const t=e.siblings,r=t.length,{index:s}=e;return n?t[(s-1+r)%r]:s===0?null:t[s-1]}function ne(e){return e.parent}function L(e,n={}){const{reverse:t=!1}=n,{children:r}=e;if(r){const{length:s}=r,o=t?s-1:0,i=t?-1:s,c=t?-1:1;for(let h=o;h!==i;h+=c){const l=r[h];if(!l.disabled&&!l.ignored)if(l.isGroup){const d=L(l,n);if(d!==null)return d}else return l}}return null}const re={getChild(){return this.ignored?null:L(this)},getParent(){const{parent:e}=this;return(e==null?void 0:e.isGroup)?e.getParent():e},getNext(e={}){return I(this,"next",e)},getPrev(e={}){return I(this,"prev",e)}};function ie(e,n){const t=n?new Set(n):void 0,r=[];function s(o){o.forEach(i=>{r.push(i),!(i.isLeaf||!i.children||i.ignored)&&(i.isGroup||t===void 0||t.has(i.key))&&s(i.children)})}return s(e),r}function se(e,n){const t=e.key;for(;n;){if(n.key===t)return!0;n=n.parent}return!1}function M(e,n,t,r,s,o=null,i=0){const c=[];return e.forEach((h,l)=>{var d;const f=Object.create(r);if(f.rawNode=h,f.siblings=c,f.level=i,f.index=l,f.isFirstChild=l===0,f.isLastChild=l+1===e.length,f.parent=o,!f.ignored){const v=s(h);Array.isArray(v)&&(f.children=M(v,n,t,r,s,f,i+1))}c.push(f),n.set(f.key,f),t.has(i)||t.set(i,[]),(d=t.get(i))===null||d===void 0||d.push(f)}),c}function ae(e,n={}){var t;const r=new Map,s=new Map,{getDisabled:o=V,getIgnored:i=U,getIsGroup:c=B,getKey:h=j}=n,l=(t=n.getChildren)!==null&&t!==void 0?t:R,d=n.ignoreEmptyChildren?u=>{const a=l(u);return Array.isArray(a)?a.length?a:null:a}:l,f=Object.assign({get key(){return h(this.rawNode)},get disabled(){return o(this.rawNode)},get isGroup(){return c(this.rawNode)},get isLeaf(){return F(this.rawNode,d)},get shallowLoaded(){return q(this.rawNode,d)},get ignored(){return i(this.rawNode)},contains(u){return se(this,u)}},re),v=M(e,r,s,f,d);function k(u){if(u==null)return null;const a=r.get(u);return a&&!a.isGroup&&!a.ignored?a:null}function S(u){if(u==null)return null;const a=r.get(u);return a&&!a.ignored?a:null}function C(u,a){const g=S(u);return g?g.getPrev(a):null}function b(u,a){const g=S(u);return g?g.getNext(a):null}function N(u){const a=S(u);return a?a.getParent():null}function w(u){const a=S(u);return a?a.getChild():null}const p={treeNodes:v,treeNodeMap:r,levelTreeNodeMap:s,maxLevel:Math.max(...s.keys()),getChildren:d,getFlattenedNodes(u){return ie(v,u)},getNode:k,getPrev:C,getNext:b,getParent:N,getChild:w,getFirstAvailableNode(){return $(v)},getPath(u,a={}){return Y(u,a,p)},getCheckedKeys(u,a={}){const{cascade:g=!0,leafOnly:m=!1,checkStrategy:K="all"}=a;return E({checkedKeys:P(u),indeterminateKeys:x(u),cascade:g,leafOnly:m,checkStrategy:K},p)},check(u,a,g={}){const{cascade:m=!0,leafOnly:K=!1,checkStrategy:y="all"}=g;return E({checkedKeys:P(a),indeterminateKeys:x(a),keysToCheck:u==null?[]:O(u),cascade:m,leafOnly:K,checkStrategy:y},p)},uncheck(u,a,g={}){const{cascade:m=!0,leafOnly:K=!1,checkStrategy:y="all"}=g;return E({checkedKeys:P(a),indeterminateKeys:x(a),keysToUncheck:u==null?[]:O(u),cascade:m,leafOnly:K,checkStrategy:y},p)},getNonLeafKeys(u={}){return D(v,u)}};return p}export{ae as a,ue as c};
